<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Pteros: Eigen::VectorwiseOp&lt; ExpressionType, Direction &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Pteros
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">Molecular modeling library for human beings!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classEigen_1_1VectorwiseOp.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classEigen_1_1VectorwiseOp-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::VectorwiseOp&lt; ExpressionType, Direction &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Pseudo expression providing partial reduction operations.  
 <a href="classEigen_1_1VectorwiseOp.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VectorwiseOp_8h_source.html">VectorwiseOp.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaf689e04c5c6e36234974fd0e24817ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>isVertical</b> = (Direction==Vertical) ? 1 : 0, 
<b>isHorizontal</b> = (Direction==Horizontal) ? 1 : 0
 }</td></tr>
<tr class="separator:aaf689e04c5c6e36234974fd0e24817ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aa307b4cd311704257a45fcd437556"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>HNormalized_Size</b>, 
<b>HNormalized_SizeMinusOne</b> = HNormalized_Size==Dynamic ? Dynamic : HNormalized_Size-1
 }</td></tr>
<tr class="separator:a03aa307b4cd311704257a45fcd437556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb7d0cf1e410781e57a4b67577941fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cb7d0cf1e410781e57a4b67577941fd"></a>
typedef ExpressionType::Scalar&#160;</td><td class="memItemRight" valign="bottom"><b>Scalar</b></td></tr>
<tr class="separator:a4cb7d0cf1e410781e57a4b67577941fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87e1223d69489f1f016d25d99c8cf5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa87e1223d69489f1f016d25d99c8cf5f"></a>
typedef ExpressionType::RealScalar&#160;</td><td class="memItemRight" valign="bottom"><b>RealScalar</b></td></tr>
<tr class="separator:aa87e1223d69489f1f016d25d99c8cf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4907c654e5810edd98e4162093b19532"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a></td></tr>
<tr class="separator:a4907c654e5810edd98e4162093b19532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897184183f7ca0939f1ee309a4d1a167"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a897184183f7ca0939f1ee309a4d1a167"></a>
typedef internal::ref_selector<br class="typebreak"/>
&lt; ExpressionType &gt;<br class="typebreak"/>
::non_const_type&#160;</td><td class="memItemRight" valign="bottom"><b>ExpressionTypeNested</b></td></tr>
<tr class="separator:a897184183f7ca0939f1ee309a4d1a167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737bf612fa7628a7d806bd6057b59f21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a737bf612fa7628a7d806bd6057b59f21"></a>
typedef internal::remove_all<br class="typebreak"/>
&lt; ExpressionTypeNested &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>ExpressionTypeNestedCleaned</b></td></tr>
<tr class="separator:a737bf612fa7628a7d806bd6057b59f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48238275ccc794871f0375896942dc14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48238275ccc794871f0375896942dc14"></a>
typedef ReturnType<br class="typebreak"/>
&lt; internal::member_minCoeff &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memItemRight" valign="bottom"><b>MinCoeffReturnType</b></td></tr>
<tr class="separator:a48238275ccc794871f0375896942dc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1370f955f04a91586c742146142917f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1370f955f04a91586c742146142917f3"></a>
typedef ReturnType<br class="typebreak"/>
&lt; internal::member_maxCoeff &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memItemRight" valign="bottom"><b>MaxCoeffReturnType</b></td></tr>
<tr class="separator:a1370f955f04a91586c742146142917f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f6c24a812336e281bcf8162d8040d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67f6c24a812336e281bcf8162d8040d7"></a>
typedef ReturnType<br class="typebreak"/>
&lt; internal::member_squaredNorm, <br class="typebreak"/>
RealScalar &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>SquaredNormReturnType</b></td></tr>
<tr class="separator:a67f6c24a812336e281bcf8162d8040d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc93e0b7463d0eb85599d4ce46007fa8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc93e0b7463d0eb85599d4ce46007fa8"></a>
typedef ReturnType<br class="typebreak"/>
&lt; internal::member_norm, <br class="typebreak"/>
RealScalar &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>NormReturnType</b></td></tr>
<tr class="separator:afc93e0b7463d0eb85599d4ce46007fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c1ca30bae03271321ec5de7e33a867"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70c1ca30bae03271321ec5de7e33a867"></a>
typedef ReturnType<br class="typebreak"/>
&lt; internal::member_blueNorm, <br class="typebreak"/>
RealScalar &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>BlueNormReturnType</b></td></tr>
<tr class="separator:a70c1ca30bae03271321ec5de7e33a867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890caf6708ce641e2ecdc08eecb0284e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a890caf6708ce641e2ecdc08eecb0284e"></a>
typedef ReturnType<br class="typebreak"/>
&lt; internal::member_stableNorm, <br class="typebreak"/>
RealScalar &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>StableNormReturnType</b></td></tr>
<tr class="separator:a890caf6708ce641e2ecdc08eecb0284e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159233a83bb9cdf3653748c0915ea7b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a159233a83bb9cdf3653748c0915ea7b2"></a>
typedef ReturnType<br class="typebreak"/>
&lt; internal::member_hypotNorm, <br class="typebreak"/>
RealScalar &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>HypotNormReturnType</b></td></tr>
<tr class="separator:a159233a83bb9cdf3653748c0915ea7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e0cb8e04b09389b8e9bbbb97c44871"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97e0cb8e04b09389b8e9bbbb97c44871"></a>
typedef ReturnType<br class="typebreak"/>
&lt; internal::member_sum &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>SumReturnType</b></td></tr>
<tr class="separator:a97e0cb8e04b09389b8e9bbbb97c44871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbac270de0591725661c5329395db586"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbac270de0591725661c5329395db586"></a>
typedef ReturnType<br class="typebreak"/>
&lt; internal::member_mean &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memItemRight" valign="bottom"><b>MeanReturnType</b></td></tr>
<tr class="separator:abbac270de0591725661c5329395db586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20f1dc78338df553296e7cdb7836f3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af20f1dc78338df553296e7cdb7836f3e"></a>
typedef ReturnType<br class="typebreak"/>
&lt; internal::member_all &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>AllReturnType</b></td></tr>
<tr class="separator:af20f1dc78338df553296e7cdb7836f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9f45c1a8ae261357be82909374cd6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a9f45c1a8ae261357be82909374cd6b"></a>
typedef ReturnType<br class="typebreak"/>
&lt; internal::member_any &gt;::Type&#160;</td><td class="memItemRight" valign="bottom"><b>AnyReturnType</b></td></tr>
<tr class="separator:a1a9f45c1a8ae261357be82909374cd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8dcafdbab5f9964b3ba9e68525ef35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba8dcafdbab5f9964b3ba9e68525ef35"></a>
typedef <a class="el" href="classEigen_1_1PartialReduxExpr.html">PartialReduxExpr</a><br class="typebreak"/>
&lt; ExpressionType, <br class="typebreak"/>
internal::member_count&lt; <a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a> &gt;<br class="typebreak"/>
, Direction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CountReturnType</b></td></tr>
<tr class="separator:aba8dcafdbab5f9964b3ba9e68525ef35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f3ce92718978e329012c75b3661838"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5f3ce92718978e329012c75b3661838"></a>
typedef ReturnType<br class="typebreak"/>
&lt; internal::member_prod &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memItemRight" valign="bottom"><b>ProdReturnType</b></td></tr>
<tr class="separator:ab5f3ce92718978e329012c75b3661838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7747054450f740d031416b602693fba3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7747054450f740d031416b602693fba3"></a>
typedef <a class="el" href="classEigen_1_1Reverse.html">Reverse</a>&lt; const <br class="typebreak"/>
ExpressionType, Direction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstReverseReturnType</b></td></tr>
<tr class="separator:a7747054450f740d031416b602693fba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b03561c0b677e71a8b8ff03768ff47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18b03561c0b677e71a8b8ff03768ff47"></a>
typedef <a class="el" href="classEigen_1_1Reverse.html">Reverse</a><br class="typebreak"/>
&lt; ExpressionType, Direction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ReverseReturnType</b></td></tr>
<tr class="separator:a18b03561c0b677e71a8b8ff03768ff47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe9aeb1ded98c24c09837a8da037a60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfe9aeb1ded98c24c09837a8da037a60"></a>
typedef <a class="el" href="classEigen_1_1Replicate.html">Replicate</a><br class="typebreak"/>
&lt; ExpressionType,(isVertical?Dynamic:1),(isHorizontal?Dynamic:1)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ReplicateReturnType</b></td></tr>
<tr class="separator:abfe9aeb1ded98c24c09837a8da037a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988c7bd3e6ae202e287a59c0a6d3d67c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a988c7bd3e6ae202e287a59c0a6d3d67c"></a>
typedef <a class="el" href="classEigen_1_1Homogeneous.html">Homogeneous</a><br class="typebreak"/>
&lt; ExpressionType, Direction &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HomogeneousReturnType</b></td></tr>
<tr class="separator:a988c7bd3e6ae202e287a59c0a6d3d67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbae778809df72722f2ecaa2e4174e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dbae778809df72722f2ecaa2e4174e0"></a>
typedef ExpressionType::PlainObject&#160;</td><td class="memItemRight" valign="bottom"><b>CrossReturnType</b></td></tr>
<tr class="separator:a1dbae778809df72722f2ecaa2e4174e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf5c62a154671b541238e73feb182b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bf5c62a154671b541238e73feb182b4"></a>
typedef <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const <br class="typebreak"/>
ExpressionType, Direction==Vertical?int(HNormalized_SizeMinusOne):int(internal::traits<br class="typebreak"/>
&lt; ExpressionType &gt;<br class="typebreak"/>
::RowsAtCompileTime), <br class="typebreak"/>
Direction==Horizontal?int(HNormalized_SizeMinusOne):int(internal::traits<br class="typebreak"/>
&lt; ExpressionType &gt;<br class="typebreak"/>
::ColsAtCompileTime)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HNormalized_Block</b></td></tr>
<tr class="separator:a4bf5c62a154671b541238e73feb182b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa761de8914859a48224986dc78e077"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaa761de8914859a48224986dc78e077"></a>
typedef <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const <br class="typebreak"/>
ExpressionType, Direction==Vertical?1:int(internal::traits<br class="typebreak"/>
&lt; ExpressionType &gt;<br class="typebreak"/>
::RowsAtCompileTime), <br class="typebreak"/>
Direction==Horizontal?1:int(internal::traits<br class="typebreak"/>
&lt; ExpressionType &gt;<br class="typebreak"/>
::ColsAtCompileTime)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HNormalized_Factors</b></td></tr>
<tr class="separator:acaa761de8914859a48224986dc78e077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6fef40103ff8b5f727cc9c8eeb3b5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c6fef40103ff8b5f727cc9c8eeb3b5f"></a>
typedef <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_quotient_op<br class="typebreak"/>
&lt; typename internal::traits<br class="typebreak"/>
&lt; ExpressionType &gt;::Scalar &gt;<br class="typebreak"/>
, const <a class="el" href="classEigen_1_1Block.html">HNormalized_Block</a>, <br class="typebreak"/>
const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a><br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Block.html">HNormalized_Factors</a>, <br class="typebreak"/>
Direction==Vertical?HNormalized_SizeMinusOne:1, <br class="typebreak"/>
Direction==Horizontal?HNormalized_SizeMinusOne:1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HNormalizedReturnType</b></td></tr>
<tr class="separator:a0c6fef40103ff8b5f727cc9c8eeb3b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad321af7262d0da2e21440f966bba745a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad321af7262d0da2e21440f966bba745a"></a>
EIGEN_DEVICE_FUNC&#160;</td><td class="memItemRight" valign="bottom"><b>VectorwiseOp</b> (ExpressionType &amp;matrix)</td></tr>
<tr class="separator:ad321af7262d0da2e21440f966bba745a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fb70046a4b1cd606e929690621df88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30fb70046a4b1cd606e929690621df88"></a>
EIGEN_DEVICE_FUNC const <br class="typebreak"/>
ExpressionType &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>_expression</b> () const </td></tr>
<tr class="separator:a30fb70046a4b1cd606e929690621df88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27a7704d08a91e93e0a68d78b30ebc4"><td class="memTemplParams" colspan="2">template&lt;typename BinaryOp &gt; </td></tr>
<tr class="memitem:ad27a7704d08a91e93e0a68d78b30ebc4"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
ReduxReturnType&lt; BinaryOp &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ad27a7704d08a91e93e0a68d78b30ebc4">redux</a> (const BinaryOp &amp;func=BinaryOp()) const </td></tr>
<tr class="separator:ad27a7704d08a91e93e0a68d78b30ebc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7447b3304fd58df97687170e9635f086"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1PartialReduxExpr.html">MinCoeffReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a7447b3304fd58df97687170e9635f086">minCoeff</a> () const </td></tr>
<tr class="separator:a7447b3304fd58df97687170e9635f086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642bd021d669b5cf58c78684fd4676a9"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1PartialReduxExpr.html">MaxCoeffReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a642bd021d669b5cf58c78684fd4676a9">maxCoeff</a> () const </td></tr>
<tr class="separator:a642bd021d669b5cf58c78684fd4676a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6044d62a7b4de31479d6fa9d699a8cbf"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1PartialReduxExpr.html">SquaredNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a6044d62a7b4de31479d6fa9d699a8cbf">squaredNorm</a> () const </td></tr>
<tr class="separator:a6044d62a7b4de31479d6fa9d699a8cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12439dc5311ae1d08d4664d0559d255"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1PartialReduxExpr.html">NormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ac12439dc5311ae1d08d4664d0559d255">norm</a> () const </td></tr>
<tr class="separator:ac12439dc5311ae1d08d4664d0559d255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f263bfa43e2c14fdd1cfb06457d2b8"><td class="memTemplParams" colspan="2">template&lt;int p&gt; </td></tr>
<tr class="memitem:ab6f263bfa43e2c14fdd1cfb06457d2b8"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
LpNormReturnType&lt; p &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ab6f263bfa43e2c14fdd1cfb06457d2b8">lpNorm</a> () const </td></tr>
<tr class="separator:ab6f263bfa43e2c14fdd1cfb06457d2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dad5dec31eaca36011d9ba14d7828ed"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1PartialReduxExpr.html">BlueNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a1dad5dec31eaca36011d9ba14d7828ed">blueNorm</a> () const </td></tr>
<tr class="separator:a1dad5dec31eaca36011d9ba14d7828ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0001ad3990adb6d5838c641547242dd2"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1PartialReduxExpr.html">StableNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a0001ad3990adb6d5838c641547242dd2">stableNorm</a> () const </td></tr>
<tr class="separator:a0001ad3990adb6d5838c641547242dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895823abcc07387e740c70a8ca6f9840"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1PartialReduxExpr.html">HypotNormReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a895823abcc07387e740c70a8ca6f9840">hypotNorm</a> () const </td></tr>
<tr class="separator:a895823abcc07387e740c70a8ca6f9840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ffd80ec52a9127c04198b97b748ca8"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1PartialReduxExpr.html">SumReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a77ffd80ec52a9127c04198b97b748ca8">sum</a> () const </td></tr>
<tr class="separator:a77ffd80ec52a9127c04198b97b748ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6068cc77b22cbd37148b83c5240edf78"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1PartialReduxExpr.html">MeanReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a6068cc77b22cbd37148b83c5240edf78">mean</a> () const </td></tr>
<tr class="separator:a6068cc77b22cbd37148b83c5240edf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bf21381502e0f8292288e7da6ef14e"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1PartialReduxExpr.html">AllReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a70bf21381502e0f8292288e7da6ef14e">all</a> () const </td></tr>
<tr class="separator:a70bf21381502e0f8292288e7da6ef14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a3af2358ba6655345c76f140e001e0"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1PartialReduxExpr.html">AnyReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ac5a3af2358ba6655345c76f140e001e0">any</a> () const </td></tr>
<tr class="separator:ac5a3af2358ba6655345c76f140e001e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ff0ad2beb748f49c7bdc435541d050"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1PartialReduxExpr.html">CountReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ad6ff0ad2beb748f49c7bdc435541d050">count</a> () const </td></tr>
<tr class="separator:ad6ff0ad2beb748f49c7bdc435541d050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875a193760aad15b33f5cabfb0555794"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1PartialReduxExpr.html">ProdReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a875a193760aad15b33f5cabfb0555794">prod</a> () const </td></tr>
<tr class="separator:a875a193760aad15b33f5cabfb0555794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbde6bf9346d386023c07b9eb3d3cc0"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a3bbde6bf9346d386023c07b9eb3d3cc0">reverse</a> () const </td></tr>
<tr class="separator:a3bbde6bf9346d386023c07b9eb3d3cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094915725d604015221205e8c4ccb993"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Reverse.html">ReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a094915725d604015221205e8c4ccb993">reverse</a> ()</td></tr>
<tr class="separator:a094915725d604015221205e8c4ccb993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfe4630c6d1209351a7d142182713af"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1Replicate.html">ReplicateReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#abbfe4630c6d1209351a7d142182713af">replicate</a> (<a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a> factor) const </td></tr>
<tr class="separator:abbfe4630c6d1209351a7d142182713af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae503797519ffcb1a49221dc7e439b0dc"><td class="memTemplParams" colspan="2">template&lt;int Factor&gt; </td></tr>
<tr class="memitem:ae503797519ffcb1a49221dc7e439b0dc"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a><br class="typebreak"/>
&lt; ExpressionType, isVertical <br class="typebreak"/>
*Factor+isHorizontal, <br class="typebreak"/>
isHorizontal *Factor+isVertical &gt;<br class="typebreak"/>
 EIGEN_DEVICE_FUNC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ae503797519ffcb1a49221dc7e439b0dc">replicate</a> (<a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a> factor=Factor) const </td></tr>
<tr class="separator:ae503797519ffcb1a49221dc7e439b0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f54a2994758cc098671d5f0f36cfa6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a61f54a2994758cc098671d5f0f36cfa6"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a61f54a2994758cc098671d5f0f36cfa6"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a61f54a2994758cc098671d5f0f36cfa6">operator=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:a61f54a2994758cc098671d5f0f36cfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the vector <em>other</em> to each subvector of <code>*this</code>. <br/></td></tr>
<tr class="separator:a61f54a2994758cc098671d5f0f36cfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60d01ea6717f9ef6fd7941cf8b99db7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad60d01ea6717f9ef6fd7941cf8b99db7"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ad60d01ea6717f9ef6fd7941cf8b99db7"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ad60d01ea6717f9ef6fd7941cf8b99db7">operator+=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:ad60d01ea6717f9ef6fd7941cf8b99db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the vector <em>other</em> to each subvector of <code>*this</code>. <br/></td></tr>
<tr class="separator:ad60d01ea6717f9ef6fd7941cf8b99db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1e97639651a9b617680ba3b3ece24a"><td class="memTemplParams" colspan="2"><a class="anchor" id="acf1e97639651a9b617680ba3b3ece24a"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:acf1e97639651a9b617680ba3b3ece24a"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#acf1e97639651a9b617680ba3b3ece24a">operator-=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:acf1e97639651a9b617680ba3b3ece24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substracts the vector <em>other</em> to each subvector of <code>*this</code>. <br/></td></tr>
<tr class="separator:acf1e97639651a9b617680ba3b3ece24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e0f0005806295e07c11534f698351e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad5e0f0005806295e07c11534f698351e"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ad5e0f0005806295e07c11534f698351e"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ad5e0f0005806295e07c11534f698351e">operator*=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:ad5e0f0005806295e07c11534f698351e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiples each subvector of <code>*this</code> by the vector <em>other</em>. <br/></td></tr>
<tr class="separator:ad5e0f0005806295e07c11534f698351e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04267f84ef1c52d88f452667cf757ae"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac04267f84ef1c52d88f452667cf757ae"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ac04267f84ef1c52d88f452667cf757ae"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC ExpressionType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ac04267f84ef1c52d88f452667cf757ae">operator/=</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:ac04267f84ef1c52d88f452667cf757ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each subvector of <code>*this</code> by the vector <em>other</em>. <br/></td></tr>
<tr class="separator:ac04267f84ef1c52d88f452667cf757ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bc8365c0cc3d18bd0cf1bf57cb6f95"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab3bc8365c0cc3d18bd0cf1bf57cb6f95"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ab3bc8365c0cc3d18bd0cf1bf57cb6f95"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE <br class="typebreak"/>
EIGEN_DEVICE_FUNC <br class="typebreak"/>
<a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_sum_op<br class="typebreak"/>
&lt; Scalar, typename <br class="typebreak"/>
OtherDerived::Scalar &gt;, const <br class="typebreak"/>
ExpressionTypeNestedCleaned, <br class="typebreak"/>
const typename ExtendedType<br class="typebreak"/>
&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ab3bc8365c0cc3d18bd0cf1bf57cb6f95">operator+</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="memdesc:ab3bc8365c0cc3d18bd0cf1bf57cb6f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expression of the sum of the vector <em>other</em> to each subvector of <code>*this</code>. <br/></td></tr>
<tr class="separator:ab3bc8365c0cc3d18bd0cf1bf57cb6f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23c6a75f7d789196e46ca3397228c34"><td class="memTemplParams" colspan="2"><a class="anchor" id="af23c6a75f7d789196e46ca3397228c34"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:af23c6a75f7d789196e46ca3397228c34"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <br class="typebreak"/>
<a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_difference_op<br class="typebreak"/>
&lt; Scalar, typename <br class="typebreak"/>
OtherDerived::Scalar &gt;, const <br class="typebreak"/>
ExpressionTypeNestedCleaned, <br class="typebreak"/>
const typename ExtendedType<br class="typebreak"/>
&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#af23c6a75f7d789196e46ca3397228c34">operator-</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="memdesc:af23c6a75f7d789196e46ca3397228c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expression of the difference between each subvector of <code>*this</code> and the vector <em>other</em>. <br/></td></tr>
<tr class="separator:af23c6a75f7d789196e46ca3397228c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82c184e7b7c62e3807c1d0085a078be"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae82c184e7b7c62e3807c1d0085a078be"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ae82c184e7b7c62e3807c1d0085a078be"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE <br class="typebreak"/>
EIGEN_DEVICE_FUNC <br class="typebreak"/>
<a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_product_op<br class="typebreak"/>
&lt; Scalar &gt;, const <br class="typebreak"/>
ExpressionTypeNestedCleaned, <br class="typebreak"/>
const typename ExtendedType<br class="typebreak"/>
&lt; OtherDerived &gt;::Type &gt;<br class="typebreak"/>
 EIGEN_DEVICE_FUNC&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ae82c184e7b7c62e3807c1d0085a078be">operator*</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="memdesc:ae82c184e7b7c62e3807c1d0085a078be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expression where each subvector is the product of the vector <em>other</em> by the corresponding subvector of <code>*this</code>. <br/></td></tr>
<tr class="separator:ae82c184e7b7c62e3807c1d0085a078be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfc3769b790bc9417c43992acfb03c7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aedfc3769b790bc9417c43992acfb03c7"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:aedfc3769b790bc9417c43992acfb03c7"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <br class="typebreak"/>
<a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_quotient_op<br class="typebreak"/>
&lt; Scalar &gt;, const <br class="typebreak"/>
ExpressionTypeNestedCleaned, <br class="typebreak"/>
const typename ExtendedType<br class="typebreak"/>
&lt; OtherDerived &gt;::Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#aedfc3769b790bc9417c43992acfb03c7">operator/</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="memdesc:aedfc3769b790bc9417c43992acfb03c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expression where each subvector is the quotient of the corresponding subvector of <code>*this</code> by the vector <em>other</em>. <br/></td></tr>
<tr class="separator:aedfc3769b790bc9417c43992acfb03c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1873a70279bd50c2c4867316fec87619"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <br class="typebreak"/>
<a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_quotient_op<br class="typebreak"/>
&lt; Scalar &gt;, const <br class="typebreak"/>
ExpressionTypeNestedCleaned, <br class="typebreak"/>
const typename <br class="typebreak"/>
OppositeExtendedType&lt; typename <br class="typebreak"/>
ReturnType<br class="typebreak"/>
&lt; internal::member_norm, <br class="typebreak"/>
RealScalar &gt;::Type &gt;::Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a1873a70279bd50c2c4867316fec87619">normalized</a> () const </td></tr>
<tr class="separator:a1873a70279bd50c2c4867316fec87619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d22c9442537bd654edb4604db7b7b57"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#a1d22c9442537bd654edb4604db7b7b57">normalize</a> ()</td></tr>
<tr class="memdesc:a1d22c9442537bd654edb4604db7b7b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize in-place each row or columns of the referenced matrix.  <a href="#a1d22c9442537bd654edb4604db7b7b57">More...</a><br/></td></tr>
<tr class="separator:a1d22c9442537bd654edb4604db7b7b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dd7c273eb2ba8defaab2d55156936b"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1VectorwiseOp.html#ab9dd7c273eb2ba8defaab2d55156936b">reverseInPlace</a> ()</td></tr>
<tr class="memdesc:ab9dd7c273eb2ba8defaab2d55156936b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the "in place" version of <a class="el" href="classEigen_1_1VectorwiseOp.html#a3bbde6bf9346d386023c07b9eb3d3cc0">VectorwiseOp::reverse</a>: it reverses each column or row of <code>*this</code>.  <a href="#ab9dd7c273eb2ba8defaab2d55156936b">More...</a><br/></td></tr>
<tr class="separator:ab9dd7c273eb2ba8defaab2d55156936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf887fe1e276c5aa54af393e423e0b8d5"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC <br class="typebreak"/>
<a class="el" href="classEigen_1_1Homogeneous.html">HomogeneousReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#gaf887fe1e276c5aa54af393e423e0b8d5">homogeneous</a> () const </td></tr>
<tr class="separator:gaf887fe1e276c5aa54af393e423e0b8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c2aeb1552cf81470565ce9f6d7935e"><td class="memTemplParams" colspan="2"><a class="anchor" id="af9c2aeb1552cf81470565ce9f6d7935e"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:af9c2aeb1552cf81470565ce9f6d7935e"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
CrossReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cross</b> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:af9c2aeb1552cf81470565ce9f6d7935e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e39a079acb4db8c3504972660fbd20"><td class="memItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1CwiseBinaryOp.html">HNormalizedReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#ga73e39a079acb4db8c3504972660fbd20">hnormalized</a> () const </td></tr>
<tr class="separator:ga73e39a079acb4db8c3504972660fbd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a2fd705a3046117d3ffb2b892c6fc4d"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ga2a2fd705a3046117d3ffb2b892c6fc4d"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const <br class="typebreak"/>
<a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a>&lt; ExpressionType, <br class="typebreak"/>
Direction &gt;::CrossReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Geometry__Module.html#ga2a2fd705a3046117d3ffb2b892c6fc4d">cross</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const </td></tr>
<tr class="separator:ga2a2fd705a3046117d3ffb2b892c6fc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ExpressionType, int Direction&gt;<br/>
class Eigen::VectorwiseOp&lt; ExpressionType, Direction &gt;</h3>

<p>Pseudo expression providing partial reduction operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExpressionType</td><td>the type of the object on which to do partial reductions </td></tr>
    <tr><td class="paramname">Direction</td><td>indicates the direction of the redux (#Vertical or #Horizontal)</td></tr>
  </table>
  </dd>
</dl>
<p>This class represents a pseudo expression with partial reduction features. It is the return type of <a class="el" href="classEigen_1_1DenseBase.html#a1c0e1b6067ec1de6cb8799da55aa7d30">DenseBase::colwise()</a> and <a class="el" href="classEigen_1_1DenseBase.html#a6daa3a3156ca0e0722bf78638e1c7f28">DenseBase::rowwise()</a> and most of the time this is the only way it is used.</p>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a1c0e1b6067ec1de6cb8799da55aa7d30">DenseBase::colwise()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a6daa3a3156ca0e0722bf78638e1c7f28">DenseBase::rowwise()</a>, class <a class="el" href="classEigen_1_1PartialReduxExpr.html" title="Generic expression of a partially reduxed matrix. ">PartialReduxExpr</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a4907c654e5810edd98e4162093b19532"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Index <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::<a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>since Eigen 3.3 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad27a7704d08a91e93e0a68d78b30ebc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<div class="memtemplate">
template&lt;typename BinaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const ReduxReturnType&lt;BinaryOp&gt;::Type <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::redux </td>
          <td>(</td>
          <td class="paramtype">const BinaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>BinaryOp()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row or column vector expression of <code>*this</code> reduxed by <em>func</em> </dd></dl>
<p>The template parameter <em>BinaryOp</em> is the type of the functor of the custom redux operator. Note that func must be an associative operator.</p>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing partial reduction operations. ">VectorwiseOp</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1c0e1b6067ec1de6cb8799da55aa7d30">DenseBase::colwise()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a6daa3a3156ca0e0722bf78638e1c7f28">DenseBase::rowwise()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7447b3304fd58df97687170e9635f086"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MinCoeffReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::minCoeff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the smallest coefficient of each column (or row) of the referenced expression.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the result is undefined if <code>*this</code> contains NaN.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a3b0b782ad0b75f6a098df8c2967d1c4c">DenseBase::minCoeff()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a642bd021d669b5cf58c78684fd4676a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MaxCoeffReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::maxCoeff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the largest coefficient of each column (or row) of the referenced expression.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the result is undefined if <code>*this</code> contains NaN.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a9bd4d9377f7eb440180ea1cf8b64c0e3">DenseBase::maxCoeff()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6044d62a7b4de31479d6fa9d699a8cbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SquaredNormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::squaredNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the squared norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>DenseBase::squaredNorm() </dd></dl>

</div>
</div>
<a class="anchor" id="ac12439dc5311ae1d08d4664d0559d255"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1PartialReduxExpr.html">NormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>DenseBase::norm() </dd></dl>

</div>
</div>
<a class="anchor" id="ab6f263bfa43e2c14fdd1cfb06457d2b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<div class="memtemplate">
template&lt;int p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const LpNormReturnType&lt;p&gt;::Type <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::lpNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>DenseBase::norm() </dd></dl>

</div>
</div>
<a class="anchor" id="a1dad5dec31eaca36011d9ba14d7828ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1PartialReduxExpr.html">BlueNormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::blueNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, using Blue's algorithm. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>DenseBase::blueNorm() </dd></dl>

</div>
</div>
<a class="anchor" id="a0001ad3990adb6d5838c641547242dd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1PartialReduxExpr.html">StableNormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::stableNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, avoiding underflow and overflow. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>DenseBase::stableNorm() </dd></dl>

</div>
</div>
<a class="anchor" id="a895823abcc07387e740c70a8ca6f9840"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1PartialReduxExpr.html">HypotNormReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::hypotNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the norm of each column (or row) of the referenced expression, avoiding underflow and overflow using a concatenation of hypot() calls. This is a vector with real entries, even if the original matrix has complex entries.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>DenseBase::hypotNorm() </dd></dl>

</div>
</div>
<a class="anchor" id="a77ffd80ec52a9127c04198b97b748ca8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1PartialReduxExpr.html">SumReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the sum of each column (or row) of the referenced expression.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#ae893580d10226bcf2a4ccd8fa653e6c8">DenseBase::sum()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6068cc77b22cbd37148b83c5240edf78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1PartialReduxExpr.html">MeanReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the mean of each column (or row) of the referenced expression.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#af88eceab67aa14d6d9cb026f3aed2052">DenseBase::mean()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a70bf21381502e0f8292288e7da6ef14e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AllReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression representing whether <b>all</b> coefficients of each respective column (or row) are <code>true</code>. This expression can be assigned to a vector with entries of type <code>bool</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a4659eb00b3766dcb546a9689db3a094e">DenseBase::all()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac5a3af2358ba6655345c76f140e001e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1PartialReduxExpr.html">AnyReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression representing whether <b>at</b> <b>least</b> one coefficient of each respective column (or row) is <code>true</code>. This expression can be assigned to a vector with entries of type <code>bool</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a7c8b20a3a0f73e34a612d23e2b761f47">DenseBase::any()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad6ff0ad2beb748f49c7bdc435541d050"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1PartialReduxExpr.html">CountReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression representing the number of <code>true</code> coefficients of each respective column (or row). This expression can be assigned to a vector whose entries have the same type as is used to index entries of the original matrix; for dense matrices, this is <code>std::ptrdiff_t</code> .</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aebde672d3e70bcc6a9905891b8f11891">DenseBase::count()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a875a193760aad15b33f5cabfb0555794"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1PartialReduxExpr.html">ProdReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::prod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a row (or column) vector expression of the product of each column (or row) of the referenced expression.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a8d5fed3fba0d308b4daf0bc826c18f22">DenseBase::prod()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3bbde6bf9346d386023c07b9eb3d3cc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const <a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a matrix expression where each column (or row) are reversed.</dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a38ea394036d8b096abf322469c80198f">DenseBase::reverse()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a094915725d604015221205e8c4ccb993"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1Reverse.html">ReverseReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable matrix expression where each column (or row) are reversed.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#a3bbde6bf9346d386023c07b9eb3d3cc0">reverse() const </a> </dd></dl>

</div>
</div>
<a class="anchor" id="abbfe4630c6d1209351a7d142182713af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::<a class="el" href="classEigen_1_1Replicate.html">ReplicateReturnType</a> <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::replicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of each column (or row) of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#abbfe4630c6d1209351a7d142182713af">VectorwiseOp::replicate()</a>, DenseBase::replicate(), class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector. ">Replicate</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae503797519ffcb1a49221dc7e439b0dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<div class="memtemplate">
template&lt;int Factor&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt;ExpressionType,isVertical*Factor+isHorizontal,isHorizontal*Factor+isVertical&gt; EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::replicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1VectorwiseOp.html#a4907c654e5810edd98e4162093b19532">Index</a>&#160;</td>
          <td class="paramname"><em>factor</em> = <code>Factor</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of each column (or row) of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"></div><!-- fragment --><p> Output: </p>
<pre class="fragment"></pre><dl class="section see"><dt>See Also</dt><dd>VectorwiseOp::replicate(Index), DenseBase::replicate(), class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector. ">Replicate</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1873a70279bd50c2c4867316fec87619"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;Scalar&gt;, const ExpressionTypeNestedCleaned, const typename OppositeExtendedType&lt;typename ReturnType&lt;internal::member_norm,RealScalar&gt;::Type&gt;::Type&gt; <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::normalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression where each column (or row) of the referenced matrix are normalized. The referenced matrix is <b>not</b> modified. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a34a7ba6e1ba1ba78a989676aff9945e9">MatrixBase::normalized()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#a1d22c9442537bd654edb4604db7b7b57" title="Normalize in-place each row or columns of the referenced matrix. ">normalize()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1d22c9442537bd654edb4604db7b7b57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType, int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC void <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize in-place each row or columns of the referenced matrix. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a1a2dd2fd1597ee6d51098aa3bb7c86f4" title="Normalizes the vector, i.e. ">MatrixBase::normalize()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#a1873a70279bd50c2c4867316fec87619">normalized()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab9dd7c273eb2ba8defaab2d55156936b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExpressionType , int Direction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classEigen_1_1VectorwiseOp.html">Eigen::VectorwiseOp</a>&lt; ExpressionType, Direction &gt;::reverseInPlace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the "in place" version of <a class="el" href="classEigen_1_1VectorwiseOp.html#a3bbde6bf9346d386023c07b9eb3d3cc0">VectorwiseOp::reverse</a>: it reverses each column or row of <code>*this</code>. </p>
<p>In most cases it is probably better to simply use the reversed expression of a matrix. However, when reversing the matrix data itself is really needed, then this "in-place" version is probably the right choice because it provides the following additional benefits:</p>
<ul>
<li>less error prone: doing the same operation with .<a class="el" href="classEigen_1_1VectorwiseOp.html#a094915725d604015221205e8c4ccb993">reverse()</a> requires special care: <div class="fragment"><div class="line">m = m.reverse().eval(); </div>
</div><!-- fragment --></li>
<li>this API enables reverse operations without the need for a temporary</li>
</ul>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#adb8045155ea45f7961fc2a5170e1d921" title="This is the &quot;in place&quot; version of reverse: it reverses *this. ">DenseBase::reverseInPlace()</a>, <a class="el" href="classEigen_1_1VectorwiseOp.html#a094915725d604015221205e8c4ccb993">reverse()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/pteros/Eigen/src/Core/util/<a class="el" href="ForwardDeclarations_8h_source.html">ForwardDeclarations.h</a></li>
<li>include/pteros/Eigen/src/Core/<a class="el" href="VectorwiseOp_8h_source.html">VectorwiseOp.h</a></li>
<li>include/pteros/Eigen/src/Core/<a class="el" href="Replicate_8h_source.html">Replicate.h</a></li>
<li>include/pteros/Eigen/src/Core/<a class="el" href="Reverse_8h_source.html">Reverse.h</a></li>
<li>include/pteros/Eigen/src/Geometry/<a class="el" href="Homogeneous_8h_source.html">Homogeneous.h</a></li>
<li>include/pteros/Eigen/src/Geometry/<a class="el" href="OrthoMethods_8h_source.html">OrthoMethods.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Eigen</b></li><li class="navelem"><a class="el" href="classEigen_1_1VectorwiseOp.html">VectorwiseOp</a></li>
    <li class="footer">Generated on Tue Mar 19 2019 15:23:16 for Pteros by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
